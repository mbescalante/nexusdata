"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4796],{7775:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>d,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"business-logic/index","title":"Procesos de Negocio","description":"NexusData proporciona m\xfaltiples formas de implementar la l\xf3gica de negocio y los flujos de trabajo de tu aplicaci\xf3n.","source":"@site/docs/business-logic/index.md","sourceDirName":"business-logic","slug":"/business-logic/","permalink":"/en/docs/business-logic/","draft":false,"unlisted":false,"editUrl":"https://github.com/nexusdata/nexusdata-docs/edit/main/docs/business-logic/index.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Roles y Permisos","permalink":"/en/docs/auth/roles-permisos"},"next":{"title":"Hooks y Middleware","permalink":"/en/docs/business-logic/hooks"}}');var o=n(4848),a=n(8453);const i={sidebar_position:7},d="Procesos de Negocio",s={},c=[{value:"Hooks y Middleware",id:"hooks-y-middleware",level:2},{value:"Hooks de modelo",id:"hooks-de-modelo",level:3},{value:"Middleware global",id:"middleware-global",level:3},{value:"Servicios",id:"servicios",level:2},{value:"Registro y uso de servicios",id:"registro-y-uso-de-servicios",level:3},{value:"Acciones personalizadas",id:"acciones-personalizadas",level:2},{value:"Uso de acciones en GraphQL",id:"uso-de-acciones-en-graphql",level:3},{value:"Eventos y suscripciones",id:"eventos-y-suscripciones",level:2},{value:"Definici\xf3n y emisi\xf3n de eventos",id:"definici\xf3n-y-emisi\xf3n-de-eventos",level:3},{value:"Suscripci\xf3n a eventos",id:"suscripci\xf3n-a-eventos",level:3},{value:"Registro de eventos y suscriptores",id:"registro-de-eventos-y-suscriptores",level:3},{value:"Tareas programadas",id:"tareas-programadas",level:2},{value:"Registro de tareas programadas",id:"registro-de-tareas-programadas",level:3},{value:"Flujos de trabajo",id:"flujos-de-trabajo",level:2},{value:"Registro y uso de flujos de trabajo",id:"registro-y-uso-de-flujos-de-trabajo",level:3},{value:"Pr\xf3ximos pasos",id:"pr\xf3ximos-pasos",level:2}];function l(r){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"procesos-de-negocio",children:"Procesos de Negocio"})}),"\n",(0,o.jsx)(e.p,{children:"NexusData proporciona m\xfaltiples formas de implementar la l\xf3gica de negocio y los flujos de trabajo de tu aplicaci\xf3n."}),"\n",(0,o.jsx)(e.h2,{id:"hooks-y-middleware",children:"Hooks y Middleware"}),"\n",(0,o.jsx)(e.p,{children:"Los hooks te permiten ejecutar c\xf3digo antes o despu\xe9s de operaciones espec\xedficas en tus modelos."}),"\n",(0,o.jsx)(e.h3,{id:"hooks-de-modelo",children:"Hooks de modelo"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// src/models/Order.js\r\nimport { Model } from '@nexusdata/core';\r\n\r\nclass Order extends Model {\r\n  static config = {\r\n    hooks: {\r\n      // Se ejecuta antes de crear un nuevo registro\r\n      beforeCreate: async (data, context) => {\r\n        if (!data.orderNumber) {\r\n          data.orderNumber = await generateOrderNumber();\r\n        }\r\n        return data;\r\n      },\r\n      \r\n      // Se ejecuta despu\xe9s de crear un nuevo registro\r\n      afterCreate: async (record, context) => {\r\n        await sendOrderConfirmation(record);\r\n        return record;\r\n      },\r\n      \r\n      // Se ejecuta antes de actualizar un registro\r\n      beforeUpdate: async (data, record, context) => {\r\n        if (data.status === 'completed' && record.status !== 'completed') {\r\n          data.completedAt = new Date();\r\n        }\r\n        return data;\r\n      },\r\n      \r\n      // Se ejecuta despu\xe9s de actualizar un registro\r\n      afterUpdate: async (updatedRecord, originalRecord, context) => {\r\n        if (updatedRecord.status !== originalRecord.status) {\r\n          await notifyStatusChange(updatedRecord);\r\n        }\r\n        return updatedRecord;\r\n      },\r\n      \r\n      // Se ejecuta antes de eliminar un registro\r\n      beforeDelete: async (record, context) => {\r\n        if (record.status === 'completed') {\r\n          throw new Error('No se pueden eliminar \xf3rdenes completadas');\r\n        }\r\n        return true; // Debe devolver true para permitir la eliminaci\xf3n\r\n      },\r\n      \r\n      // Se ejecuta despu\xe9s de eliminar un registro\r\n      afterDelete: async (deletedRecord, context) => {\r\n        await logOrderDeletion(deletedRecord);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nexport default Order;\n"})}),"\n",(0,o.jsx)(e.h3,{id:"middleware-global",children:"Middleware global"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// src/middleware/auditLog.js\r\nexport default function auditLogMiddleware() {\r\n  return {\r\n    beforeCreate: async (data, context, { model }) => {\r\n      console.log(`Creando ${model.name}:`, data);\r\n      return data;\r\n    },\r\n    \r\n    afterCreate: async (record, context, { model }) => {\r\n      await createAuditRecord({\r\n        action: 'CREATE',\r\n        model: model.name,\r\n        recordId: record.id,\r\n        userId: context.user?.id,\r\n        timestamp: new Date(),\r\n        changes: record\r\n      });\r\n      return record;\r\n    },\r\n    \r\n    beforeUpdate: async (data, record, context, { model }) => {\r\n      console.log(`Actualizando ${model.name}:`, { id: record.id, changes: data });\r\n      return data;\r\n    },\r\n    \r\n    afterUpdate: async (updatedRecord, originalRecord, context, { model }) => {\r\n      const changes = calculateChanges(updatedRecord, originalRecord);\r\n      \r\n      await createAuditRecord({\r\n        action: 'UPDATE',\r\n        model: model.name,\r\n        recordId: updatedRecord.id,\r\n        userId: context.user?.id,\r\n        timestamp: new Date(),\r\n        changes\r\n      });\r\n      \r\n      return updatedRecord;\r\n    },\r\n    \r\n    beforeDelete: async (record, context, { model }) => {\r\n      console.log(`Eliminando ${model.name}:`, record.id);\r\n      return true;\r\n    },\r\n    \r\n    afterDelete: async (deletedRecord, context, { model }) => {\r\n      await createAuditRecord({\r\n        action: 'DELETE',\r\n        model: model.name,\r\n        recordId: deletedRecord.id,\r\n        userId: context.user?.id,\r\n        timestamp: new Date(),\r\n        changes: deletedRecord\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\n// Registrar middleware globalmente\r\n// nexusdata.config.js\r\nmodule.exports = {\r\n  // ... otras configuraciones\r\n  middleware: [\r\n    'src/middleware/auditLog.js',\r\n    // otros middleware\r\n  ]\r\n};\n"})}),"\n",(0,o.jsx)(e.h2,{id:"servicios",children:"Servicios"}),"\n",(0,o.jsx)(e.p,{children:"Los servicios te permiten encapsular l\xf3gica compleja y reutilizable."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// src/services/OrderService.js\r\nimport { Service } from '@nexusdata/core';\r\nimport { Order, LineItem, Product, Notification } from '../models';\r\nimport { InsufficientStockError } from '../errors';\r\n\r\nclass OrderService extends Service {\r\n  async createOrder(data, context) {\r\n    // Iniciar transacci\xf3n\r\n    return this.db.transaction(async (tx) => {\r\n      // Verificar stock disponible\r\n      for (const item of data.items) {\r\n        const product = await tx.findOne(Product, { id: item.productId });\r\n        \r\n        if (!product) {\r\n          throw new Error(`Producto no encontrado: ${item.productId}`);\r\n        }\r\n        \r\n        if (product.stock < item.quantity) {\r\n          throw new InsufficientStockError(product.name, product.stock, item.quantity);\r\n        }\r\n      }\r\n      \r\n      // Calcular total\r\n      let total = 0;\r\n      const lineItems = [];\r\n      \r\n      for (const item of data.items) {\r\n        const product = await tx.findOne(Product, { id: item.productId });\r\n        const price = item.price || product.price;\r\n        const subtotal = price * item.quantity;\r\n        \r\n        lineItems.push({\r\n          productId: product.id,\r\n          productName: product.name,\r\n          quantity: item.quantity,\r\n          price,\r\n          subtotal\r\n        });\r\n        \r\n        total += subtotal;\r\n        \r\n        // Actualizar stock\r\n        await tx.update(Product, {\r\n          id: product.id,\r\n          stock: product.stock - item.quantity\r\n        });\r\n      }\r\n      \r\n      // Crear orden\r\n      const order = await tx.create(Order, {\r\n        userId: context.user.id,\r\n        status: 'pending',\r\n        total,\r\n        ...data,\r\n      });\r\n      \r\n      // Crear l\xedneas de orden\r\n      for (const item of lineItems) {\r\n        await tx.create(LineItem, {\r\n          ...item,\r\n          orderId: order.id\r\n        });\r\n      }\r\n      \r\n      // Enviar notificaci\xf3n\r\n      await tx.create(Notification, {\r\n        userId: context.user.id,\r\n        type: 'order_created',\r\n        title: 'Nuevo pedido',\r\n        message: `Tu pedido #${order.id} ha sido creado exitosamente.`,\r\n        data: { orderId: order.id }\r\n      });\r\n      \r\n      return order;\r\n    });\r\n  }\r\n  \r\n  async processPayment(orderId, paymentData, context) {\r\n    const order = await this.db.findOne(Order, { id: orderId });\r\n    \r\n    if (!order) {\r\n      throw new Error('Orden no encontrada');\r\n    }\r\n    \r\n    if (order.status !== 'pending') {\r\n      throw new Error(`No se puede procesar el pago para una orden en estado ${order.status}`);\r\n    }\r\n    \r\n    // Procesar pago con un gateway externo\r\n    const paymentResult = await this.paymentGateway.processPayment({\r\n      amount: order.total,\r\n      currency: 'EUR',\r\n      description: `Pago de orden #${order.id}`,\r\n      ...paymentData\r\n    });\r\n    \r\n    if (paymentResult.success) {\r\n      // Actualizar estado de la orden\r\n      await this.db.update(Order, {\r\n        id: order.id,\r\n        status: 'paid',\r\n        paymentId: paymentResult.id,\r\n        paymentMethod: paymentData.method\r\n      });\r\n      \r\n      // Notificar al usuario\r\n      await this.db.create(Notification, {\r\n        userId: order.userId,\r\n        type: 'payment_successful',\r\n        title: 'Pago procesado',\r\n        message: `El pago para tu pedido #${order.id} ha sido procesado exitosamente.`,\r\n        data: { orderId: order.id }\r\n      });\r\n      \r\n      // Enviar correo de confirmaci\xf3n\r\n      await this.emailService.sendOrderConfirmation(order.id);\r\n      \r\n      return { success: true, order: await this.db.findOne(Order, { id: order.id }) };\r\n    } else {\r\n      // Registrar error de pago\r\n      await this.db.create(PaymentError, {\r\n        orderId: order.id,\r\n        code: paymentResult.error.code,\r\n        message: paymentResult.error.message,\r\n        data: paymentResult.error\r\n      });\r\n      \r\n      return { success: false, error: paymentResult.error };\r\n    }\r\n  }\r\n}\r\n\r\nexport default OrderService;\n"})}),"\n",(0,o.jsx)(e.h3,{id:"registro-y-uso-de-servicios",children:"Registro y uso de servicios"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// nexusdata.config.js\r\nmodule.exports = {\r\n  // ... otras configuraciones\r\n  services: [\r\n    'src/services/OrderService',\r\n    'src/services/UserService',\r\n    'src/services/NotificationService',\r\n    'src/services/ReportingService'\r\n  ]\r\n};\r\n\r\n// Uso en resolvers de GraphQL\r\nconst resolvers = {\r\n  Mutation: {\r\n    createOrder: async (_, { input }, context) => {\r\n      const orderService = context.services.OrderService;\r\n      return orderService.createOrder(input, context);\r\n    },\r\n    \r\n    processPayment: async (_, { orderId, paymentData }, context) => {\r\n      const orderService = context.services.OrderService;\r\n      return orderService.processPayment(orderId, paymentData, context);\r\n    }\r\n  }\r\n};\n"})}),"\n",(0,o.jsx)(e.h2,{id:"acciones-personalizadas",children:"Acciones personalizadas"}),"\n",(0,o.jsx)(e.p,{children:"Las acciones te permiten definir operaciones espec\xedficas de modelo."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// src/models/Product.js\r\nimport { Model } from '@nexusdata/core';\r\n\r\nclass Product extends Model {\r\n  static config = {\r\n    actions: {\r\n      // Acci\xf3n para ajustar el stock de un producto\r\n      adjustStock: {\r\n        input: {\r\n          quantity: 'Int!', // La cantidad a ajustar (positivo para a\xf1adir, negativo para restar)\r\n          reason: 'String!'  // Raz\xf3n del ajuste\r\n        },\r\n        output: 'Product!', // Tipo de retorno\r\n        resolver: async (product, { quantity, reason }, context) => {\r\n          const newStock = product.stock + quantity;\r\n          \r\n          if (newStock < 0) {\r\n            throw new Error('El stock no puede ser negativo');\r\n          }\r\n          \r\n          // Registrar el ajuste\r\n          await context.db.create('StockAdjustment', {\r\n            productId: product.id,\r\n            quantity,\r\n            reason,\r\n            previousStock: product.stock,\r\n            newStock,\r\n            userId: context.user?.id,\r\n            timestamp: new Date()\r\n          });\r\n          \r\n          // Actualizar el producto\r\n          return context.db.update('Product', {\r\n            id: product.id,\r\n            stock: newStock\r\n          });\r\n        }\r\n      },\r\n      \r\n      // Acci\xf3n para aplicar un descuento\r\n      applyDiscount: {\r\n        input: {\r\n          percentage: 'Float!', // Porcentaje de descuento (entre 0 y 100)\r\n          validUntil: 'DateTime' // Fecha opcional de expiraci\xf3n\r\n        },\r\n        output: 'Product!',\r\n        resolver: async (product, { percentage, validUntil }, context) => {\r\n          if (percentage < 0 || percentage > 100) {\r\n            throw new Error('El porcentaje debe estar entre 0 y 100');\r\n          }\r\n          \r\n          const originalPrice = product.originalPrice || product.price;\r\n          const discountedPrice = originalPrice * (1 - percentage / 100);\r\n          \r\n          return context.db.update('Product', {\r\n            id: product.id,\r\n            price: discountedPrice,\r\n            originalPrice: product.originalPrice || product.price,\r\n            discountPercentage: percentage,\r\n            discountValidUntil: validUntil\r\n          });\r\n        }\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nexport default Product;\n"})}),"\n",(0,o.jsx)(e.h3,{id:"uso-de-acciones-en-graphql",children:"Uso de acciones en GraphQL"}),"\n",(0,o.jsx)(e.p,{children:"Las acciones se exponen autom\xe1ticamente como mutaciones de GraphQL:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-graphql",children:"mutation AdjustProductStock($id: ID!, $input: ProductAdjustStockInput!) {\r\n  productAdjustStock(id: $id, input: $input) {\r\n    id\r\n    name\r\n    stock\r\n  }\r\n}\r\n\r\nmutation ApplyProductDiscount($id: ID!, $input: ProductApplyDiscountInput!) {\r\n  productApplyDiscount(id: $id, input: $input) {\r\n    id\r\n    name\r\n    price\r\n    originalPrice\r\n    discountPercentage\r\n    discountValidUntil\r\n  }\r\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"eventos-y-suscripciones",children:"Eventos y suscripciones"}),"\n",(0,o.jsx)(e.p,{children:"El sistema de eventos te permite implementar comunicaci\xf3n as\xedncrona entre componentes."}),"\n",(0,o.jsx)(e.h3,{id:"definici\xf3n-y-emisi\xf3n-de-eventos",children:"Definici\xf3n y emisi\xf3n de eventos"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// src/events/orderEvents.js\r\nimport { defineEvents } from '@nexusdata/core';\r\n\r\nexport default defineEvents({\r\n  'order.created': {\r\n    description: 'Se dispara cuando se crea una nueva orden',\r\n    payload: 'Order!'\r\n  },\r\n  'order.statusChanged': {\r\n    description: 'Se dispara cuando cambia el estado de una orden',\r\n    payload: {\r\n      order: 'Order!',\r\n      previousStatus: 'String!',\r\n      newStatus: 'String!'\r\n    }\r\n  },\r\n  'order.completed': {\r\n    description: 'Se dispara cuando una orden se marca como completada',\r\n    payload: 'Order!'\r\n  }\r\n});\r\n\r\n// Emisi\xf3n de eventos en un hook\r\n// src/models/Order.js\r\nimport { Model } from '@nexusdata/core';\r\n\r\nclass Order extends Model {\r\n  static config = {\r\n    hooks: {\r\n      afterCreate: async (record, context) => {\r\n        // Emitir evento order.created\r\n        await context.events.emit('order.created', record);\r\n        return record;\r\n      },\r\n      \r\n      afterUpdate: async (updatedRecord, originalRecord, context) => {\r\n        // Si el estado cambi\xf3, emitir evento order.statusChanged\r\n        if (updatedRecord.status !== originalRecord.status) {\r\n          await context.events.emit('order.statusChanged', {\r\n            order: updatedRecord,\r\n            previousStatus: originalRecord.status,\r\n            newStatus: updatedRecord.status\r\n          });\r\n          \r\n          // Si se complet\xf3 la orden, emitir evento order.completed\r\n          if (updatedRecord.status === 'completed') {\r\n            await context.events.emit('order.completed', updatedRecord);\r\n          }\r\n        }\r\n        \r\n        return updatedRecord;\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nexport default Order;\n"})}),"\n",(0,o.jsx)(e.h3,{id:"suscripci\xf3n-a-eventos",children:"Suscripci\xf3n a eventos"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// src/subscribers/orderSubscribers.js\r\nimport { defineSubscribers } from '@nexusdata/core';\r\n\r\nexport default defineSubscribers({\r\n  'order.created': async (order, context) => {\r\n    // Enviar correo de confirmaci\xf3n\r\n    await context.services.EmailService.sendTemplate('order_confirmation', {\r\n      to: order.email,\r\n      subject: `Confirmaci\xf3n de pedido #${order.id}`,\r\n      data: {\r\n        orderNumber: order.id,\r\n        customer: order.customerName,\r\n        total: formatCurrency(order.total)\r\n      }\r\n    });\r\n    \r\n    // Notificar al equipo de ventas\r\n    await context.services.NotificationService.notifyTeam('sales', {\r\n      title: 'Nueva orden recibida',\r\n      message: `Orden #${order.id} por ${formatCurrency(order.total)}`,\r\n      data: { orderId: order.id }\r\n    });\r\n  },\r\n  \r\n  'order.statusChanged': async ({ order, previousStatus, newStatus }, context) => {\r\n    // Enviar notificaci\xf3n al cliente\r\n    await context.services.EmailService.sendTemplate('order_status_changed', {\r\n      to: order.email,\r\n      subject: `Actualizaci\xf3n de tu pedido #${order.id}`,\r\n      data: {\r\n        orderNumber: order.id,\r\n        customer: order.customerName,\r\n        previousStatus,\r\n        newStatus,\r\n        statusDescription: getStatusDescription(newStatus)\r\n      }\r\n    });\r\n    \r\n    // Registrar cambio de estado\r\n    await context.db.create('OrderStatusHistory', {\r\n      orderId: order.id,\r\n      previousStatus,\r\n      newStatus,\r\n      timestamp: new Date(),\r\n      userId: context.user?.id\r\n    });\r\n  },\r\n  \r\n  'order.completed': async (order, context) => {\r\n    // Generar factura\r\n    const invoice = await context.services.InvoiceService.generateInvoice(order.id);\r\n    \r\n    // Enviar factura por correo\r\n    await context.services.EmailService.sendTemplate('order_invoice', {\r\n      to: order.email,\r\n      subject: `Factura para tu pedido #${order.id}`,\r\n      data: {\r\n        orderNumber: order.id,\r\n        customer: order.customerName,\r\n        invoiceNumber: invoice.number,\r\n        invoiceUrl: invoice.downloadUrl\r\n      },\r\n      attachments: [\r\n        {\r\n          filename: `factura-${invoice.number}.pdf`,\r\n          path: invoice.filePath\r\n        }\r\n      ]\r\n    });\r\n    \r\n    // Actualizar estad\xedsticas de ventas\r\n    await context.services.ReportingService.updateSalesStats(order);\r\n  }\r\n});\n"})}),"\n",(0,o.jsx)(e.h3,{id:"registro-de-eventos-y-suscriptores",children:"Registro de eventos y suscriptores"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// nexusdata.config.js\r\nmodule.exports = {\r\n  // ... otras configuraciones\r\n  events: [\r\n    'src/events/orderEvents',\r\n    'src/events/userEvents',\r\n    'src/events/productEvents'\r\n  ],\r\n  subscribers: [\r\n    'src/subscribers/orderSubscribers',\r\n    'src/subscribers/userSubscribers',\r\n    'src/subscribers/notificationSubscribers'\r\n  ]\r\n};\n"})}),"\n",(0,o.jsx)(e.h2,{id:"tareas-programadas",children:"Tareas programadas"}),"\n",(0,o.jsx)(e.p,{children:"Las tareas programadas te permiten ejecutar c\xf3digo en intervalos espec\xedficos."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// src/tasks/cleanupTask.js\r\nimport { defineTask } from '@nexusdata/core';\r\n\r\nexport default defineTask({\r\n  name: 'cleanup',\r\n  description: 'Elimina datos temporales y registros antiguos',\r\n  schedule: '0 3 * * *', // Ejecutar a las 3 AM todos los d\xedas (formato cron)\r\n  handler: async (context) => {\r\n    const { db } = context;\r\n    \r\n    // Eliminar sesiones expiradas\r\n    const thirtyDaysAgo = new Date();\r\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n    \r\n    const result = await db.delete('Session', {\r\n      where: {\r\n        lastActive: {\r\n          lt: thirtyDaysAgo\r\n        }\r\n      }\r\n    });\r\n    \r\n    console.log(`Eliminadas ${result.count} sesiones expiradas`);\r\n    \r\n    // Archivar notificaciones le\xeddas antiguas\r\n    const sevenDaysAgo = new Date();\r\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\r\n    \r\n    const notificationsToArchive = await db.findMany('Notification', {\r\n      where: {\r\n        read: true,\r\n        createdAt: {\r\n          lt: sevenDaysAgo\r\n        },\r\n        archived: false\r\n      }\r\n    });\r\n    \r\n    for (const notification of notificationsToArchive) {\r\n      await db.update('Notification', {\r\n        id: notification.id,\r\n        archived: true\r\n      });\r\n    }\r\n    \r\n    console.log(`Archivadas ${notificationsToArchive.length} notificaciones`);\r\n    \r\n    return {\r\n      sessionsDeleted: result.count,\r\n      notificationsArchived: notificationsToArchive.length\r\n    };\r\n  }\r\n});\r\n\r\n// src/tasks/reportingTask.js\r\nimport { defineTask } from '@nexusdata/core';\r\n\r\nexport default defineTask({\r\n  name: 'dailyReporting',\r\n  description: 'Genera informes diarios de ventas y actividad',\r\n  schedule: '0 5 * * *', // Ejecutar a las 5 AM todos los d\xedas\r\n  handler: async (context) => {\r\n    const { db, services } = context;\r\n    const yesterday = new Date();\r\n    yesterday.setDate(yesterday.getDate() - 1);\r\n    \r\n    // Formatear fecha para consultas y nombres de archivo\r\n    const dateStr = yesterday.toISOString().split('T')[0];\r\n    \r\n    // Generar informe de ventas\r\n    const salesReport = await services.ReportingService.generateDailySalesReport(dateStr);\r\n    \r\n    // Enviar informe a administradores\r\n    const admins = await db.findMany('User', {\r\n      where: {\r\n        role: 'ADMIN'\r\n      }\r\n    });\r\n    \r\n    for (const admin of admins) {\r\n      await services.EmailService.sendTemplate('daily_report', {\r\n        to: admin.email,\r\n        subject: `Informe diario de ventas: ${dateStr}`,\r\n        data: {\r\n          date: dateStr,\r\n          salesTotal: salesReport.total,\r\n          orderCount: salesReport.orderCount,\r\n          averageOrderValue: salesReport.averageOrderValue,\r\n          topProducts: salesReport.topProducts\r\n        },\r\n        attachments: [\r\n          {\r\n            filename: `ventas-diarias-${dateStr}.pdf`,\r\n            path: salesReport.pdfPath\r\n          }\r\n        ]\r\n      });\r\n    }\r\n    \r\n    return {\r\n      date: dateStr,\r\n      reportGenerated: true,\r\n      recipientCount: admins.length\r\n    };\r\n  }\r\n});\n"})}),"\n",(0,o.jsx)(e.h3,{id:"registro-de-tareas-programadas",children:"Registro de tareas programadas"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// nexusdata.config.js\r\nmodule.exports = {\r\n  // ... otras configuraciones\r\n  tasks: [\r\n    'src/tasks/cleanupTask',\r\n    'src/tasks/reportingTask',\r\n    'src/tasks/backupTask',\r\n    'src/tasks/inventoryCheckTask'\r\n  ]\r\n};\n"})}),"\n",(0,o.jsx)(e.h2,{id:"flujos-de-trabajo",children:"Flujos de trabajo"}),"\n",(0,o.jsx)(e.p,{children:"Los flujos de trabajo te permiten definir procesos de negocio complejos con m\xfaltiples pasos."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// src/workflows/orderFulfillment.js\r\nimport { defineWorkflow } from '@nexusdata/core';\r\n\r\nexport default defineWorkflow({\r\n  name: 'orderFulfillment',\r\n  description: 'Proceso de cumplimiento de pedidos desde la recepci\xf3n hasta la entrega',\r\n  \r\n  // Definir los estados posibles del flujo\r\n  states: {\r\n    RECEIVED: {\r\n      description: 'Pedido recibido y pago confirmado',\r\n      initial: true\r\n    },\r\n    PROCESSING: {\r\n      description: 'Pedido en procesamiento'\r\n    },\r\n    READY_FOR_SHIPPING: {\r\n      description: 'Pedido listo para env\xedo'\r\n    },\r\n    SHIPPED: {\r\n      description: 'Pedido enviado'\r\n    },\r\n    DELIVERED: {\r\n      description: 'Pedido entregado'\r\n    },\r\n    CANCELLED: {\r\n      description: 'Pedido cancelado',\r\n      terminal: true\r\n    },\r\n    COMPLETED: {\r\n      description: 'Pedido completado satisfactoriamente',\r\n      terminal: true\r\n    }\r\n  },\r\n  \r\n  // Definir las transiciones posibles entre estados\r\n  transitions: {\r\n    startProcessing: {\r\n      from: 'RECEIVED',\r\n      to: 'PROCESSING',\r\n      action: async (context, order) => {\r\n        // Verificar inventario\r\n        const lineItems = await context.db.findMany('LineItem', {\r\n          where: { orderId: order.id }\r\n        });\r\n        \r\n        for (const item of lineItems) {\r\n          const product = await context.db.findOne('Product', { id: item.productId });\r\n          \r\n          if (product.stock < item.quantity) {\r\n            throw new Error(`Stock insuficiente para ${product.name}`);\r\n          }\r\n        }\r\n        \r\n        // Reservar inventario\r\n        for (const item of lineItems) {\r\n          await context.db.update('Product', {\r\n            id: item.productId,\r\n            reservedStock: { increment: item.quantity }\r\n          });\r\n        }\r\n        \r\n        // Asignar a un operador\r\n        const availableOperators = await context.db.findMany('User', {\r\n          where: {\r\n            role: 'OPERATOR',\r\n            status: 'ACTIVE'\r\n          },\r\n          orderBy: {\r\n            assignedOrders: {\r\n              _count: 'asc'\r\n            }\r\n          },\r\n          take: 1\r\n        });\r\n        \r\n        if (availableOperators.length > 0) {\r\n          await context.db.create('OrderAssignment', {\r\n            orderId: order.id,\r\n            userId: availableOperators[0].id,\r\n            assignedAt: new Date()\r\n          });\r\n        }\r\n        \r\n        // Notificar al equipo de operaciones\r\n        await context.services.NotificationService.notifyTeam('operations', {\r\n          title: 'Nuevo pedido para procesar',\r\n          message: `El pedido #${order.id} est\xe1 listo para ser procesado`,\r\n          data: { orderId: order.id }\r\n        });\r\n        \r\n        return {\r\n          message: `Pedido #${order.id} en procesamiento`,\r\n          assignedTo: availableOperators[0]?.id\r\n        };\r\n      }\r\n    },\r\n    \r\n    markReadyForShipping: {\r\n      from: 'PROCESSING',\r\n      to: 'READY_FOR_SHIPPING',\r\n      action: async (context, order) => {\r\n        // Generar etiqueta de env\xedo\r\n        const shippingLabel = await context.services.ShippingService.generateLabel(order.id);\r\n        \r\n        // Actualizar orden con informaci\xf3n de env\xedo\r\n        await context.db.update('Order', {\r\n          id: order.id,\r\n          shippingLabelUrl: shippingLabel.url,\r\n          trackingNumber: shippingLabel.trackingNumber,\r\n          shippingCarrier: shippingLabel.carrier\r\n        });\r\n        \r\n        // Notificar al equipo de log\xedstica\r\n        await context.services.NotificationService.notifyTeam('logistics', {\r\n          title: 'Pedido listo para env\xedo',\r\n          message: `El pedido #${order.id} est\xe1 listo para ser enviado`,\r\n          data: { \r\n            orderId: order.id,\r\n            trackingNumber: shippingLabel.trackingNumber\r\n          }\r\n        });\r\n        \r\n        return {\r\n          message: `Pedido #${order.id} listo para env\xedo`,\r\n          trackingNumber: shippingLabel.trackingNumber\r\n        };\r\n      }\r\n    },\r\n    \r\n    markShipped: {\r\n      from: 'READY_FOR_SHIPPING',\r\n      to: 'SHIPPED',\r\n      action: async (context, order) => {\r\n        // Actualizar orden\r\n        await context.db.update('Order', {\r\n          id: order.id,\r\n          shippedAt: new Date()\r\n        });\r\n        \r\n        // Actualizar inventario (convertir stock reservado a retirado)\r\n        const lineItems = await context.db.findMany('LineItem', {\r\n          where: { orderId: order.id }\r\n        });\r\n        \r\n        for (const item of lineItems) {\r\n          await context.db.update('Product', {\r\n            id: item.productId,\r\n            reservedStock: { decrement: item.quantity },\r\n            stock: { decrement: item.quantity }\r\n          });\r\n        }\r\n        \r\n        // Notificar al cliente\r\n        await context.services.EmailService.sendTemplate('order_shipped', {\r\n          to: order.email,\r\n          subject: `Tu pedido #${order.id} ha sido enviado`,\r\n          data: {\r\n            orderNumber: order.id,\r\n            trackingNumber: order.trackingNumber,\r\n            carrier: order.shippingCarrier,\r\n            trackingUrl: getTrackingUrl(order.shippingCarrier, order.trackingNumber)\r\n          }\r\n        });\r\n        \r\n        return {\r\n          message: `Pedido #${order.id} enviado`,\r\n          shippedAt: new Date()\r\n        };\r\n      }\r\n    },\r\n    \r\n    markDelivered: {\r\n      from: 'SHIPPED',\r\n      to: 'DELIVERED',\r\n      action: async (context, order) => {\r\n        // Actualizar orden\r\n        await context.db.update('Order', {\r\n          id: order.id,\r\n          deliveredAt: new Date()\r\n        });\r\n        \r\n        // Notificar al cliente\r\n        await context.services.EmailService.sendTemplate('order_delivered', {\r\n          to: order.email,\r\n          subject: `Tu pedido #${order.id} ha sido entregado`,\r\n          data: {\r\n            orderNumber: order.id,\r\n            deliveryDate: new Date().toLocaleDateString()\r\n          }\r\n        });\r\n        \r\n        // Enviar solicitud de valoraci\xf3n despu\xe9s de un d\xeda\r\n        await context.services.SchedulerService.scheduleTask({\r\n          taskId: `review-request-${order.id}`,\r\n          executeAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 horas despu\xe9s\r\n          handler: async () => {\r\n            await context.services.EmailService.sendTemplate('review_request', {\r\n              to: order.email,\r\n              subject: `\xbfC\xf3mo valorar\xedas tu experiencia con tu pedido #${order.id}?`,\r\n              data: {\r\n                orderNumber: order.id,\r\n                reviewUrl: `https://tutienda.com/reviews?order=${order.id}&token=${generateReviewToken(order.id)}`\r\n              }\r\n            });\r\n          }\r\n        });\r\n        \r\n        return {\r\n          message: `Pedido #${order.id} entregado`,\r\n          deliveredAt: new Date()\r\n        };\r\n      }\r\n    },\r\n    \r\n    completeOrder: {\r\n      from: 'DELIVERED',\r\n      to: 'COMPLETED',\r\n      action: async (context, order) => {\r\n        // Marcar como completado\r\n        await context.db.update('Order', {\r\n          id: order.id,\r\n          completedAt: new Date(),\r\n          status: 'completed'\r\n        });\r\n        \r\n        // Actualizar estad\xedsticas del cliente\r\n        await context.services.CustomerService.updatePurchaseStats(order.userId);\r\n        \r\n        // Aplicar puntos de fidelidad\r\n        if (order.userId) {\r\n          const loyaltyPoints = Math.floor(order.total / 10); // 1 punto por cada 10\u20ac\r\n          \r\n          await context.services.LoyaltyService.addPoints(order.userId, loyaltyPoints, {\r\n            source: 'purchase',\r\n            reference: order.id\r\n          });\r\n          \r\n          // Notificar al cliente sobre los puntos\r\n          await context.services.NotificationService.notify(order.userId, {\r\n            title: 'Puntos de fidelidad a\xf1adidos',\r\n            message: `Has ganado ${loyaltyPoints} puntos por tu compra #${order.id}`,\r\n            type: 'loyalty_points',\r\n            data: { \r\n              points: loyaltyPoints,\r\n              orderId: order.id\r\n            }\r\n          });\r\n        }\r\n        \r\n        return {\r\n          message: `Pedido #${order.id} completado`,\r\n          completedAt: new Date(),\r\n          loyaltyPointsAwarded: loyaltyPoints\r\n        };\r\n      }\r\n    },\r\n    \r\n    cancelOrder: {\r\n      from: ['RECEIVED', 'PROCESSING', 'READY_FOR_SHIPPING'],\r\n      to: 'CANCELLED',\r\n      action: async (context, order, { reason }) => {\r\n        // Actualizar orden\r\n        await context.db.update('Order', {\r\n          id: order.id,\r\n          cancelledAt: new Date(),\r\n          cancellationReason: reason,\r\n          status: 'cancelled'\r\n        });\r\n        \r\n        // Devolver stock reservado\r\n        if (order.state === 'PROCESSING' || order.state === 'READY_FOR_SHIPPING') {\r\n          const lineItems = await context.db.findMany('LineItem', {\r\n            where: { orderId: order.id }\r\n          });\r\n          \r\n          for (const item of lineItems) {\r\n            await context.db.update('Product', {\r\n              id: item.productId,\r\n              reservedStock: { decrement: item.quantity }\r\n            });\r\n          }\r\n        }\r\n        \r\n        // Procesar reembolso si es necesario\r\n        if (order.paymentId) {\r\n          try {\r\n            const refundResult = await context.services.PaymentService.refundPayment(order.paymentId);\r\n            \r\n            await context.db.create('Refund', {\r\n              orderId: order.id,\r\n              amount: order.total,\r\n              paymentId: order.paymentId,\r\n              refundId: refundResult.id,\r\n              status: 'completed',\r\n              reason\r\n            });\r\n            \r\n            // Notificar al cliente sobre el reembolso\r\n            await context.services.EmailService.sendTemplate('order_cancelled_with_refund', {\r\n              to: order.email,\r\n              subject: `Tu pedido #${order.id} ha sido cancelado`,\r\n              data: {\r\n                orderNumber: order.id,\r\n                refundAmount: formatCurrency(order.total),\r\n                reason\r\n              }\r\n            });\r\n          } catch (error) {\r\n            // Registrar error y notificar al equipo de soporte\r\n            await context.db.create('RefundError', {\r\n              orderId: order.id,\r\n              paymentId: order.paymentId,\r\n              error: error.message,\r\n              errorDetails: JSON.stringify(error)\r\n            });\r\n            \r\n            await context.services.NotificationService.notifyTeam('support', {\r\n              title: 'Error en reembolso',\r\n              message: `Error al procesar reembolso para pedido #${order.id}: ${error.message}`,\r\n              data: { \r\n                orderId: order.id,\r\n                error: error.message\r\n              },\r\n              priority: 'high'\r\n            });\r\n          }\r\n        } else {\r\n          // Notificar al cliente sin reembolso\r\n          await context.services.EmailService.sendTemplate('order_cancelled', {\r\n            to: order.email,\r\n            subject: `Tu pedido #${order.id} ha sido cancelado`,\r\n            data: {\r\n              orderNumber: order.id,\r\n              reason\r\n            }\r\n          });\r\n        }\r\n        \r\n        return {\r\n          message: `Pedido #${order.id} cancelado`,\r\n          cancelledAt: new Date(),\r\n          reason\r\n        };\r\n      }\r\n    }\r\n  },\r\n  \r\n  // Listeners para eventos externos que pueden afectar al workflow\r\n  listeners: {\r\n    'payment.failed': async (context, { orderId }) => {\r\n      const order = await context.db.findOne('Order', { id: orderId });\r\n      \r\n      if (order && order.state === 'RECEIVED') {\r\n        await context.workflows.orderFulfillment.transition(order.id, 'cancelOrder', {\r\n          reason: 'Fallo en el pago'\r\n        });\r\n      }\r\n    },\r\n    \r\n    'shipping.delayed': async (context, { trackingNumber }) => {\r\n      const order = await context.db.findOne('Order', { trackingNumber });\r\n      \r\n      if (order && order.state === 'SHIPPED') {\r\n        // Notificar al cliente sobre el retraso\r\n        await context.services.EmailService.sendTemplate('shipping_delay', {\r\n          to: order.email,\r\n          subject: `Retraso en la entrega de tu pedido #${order.id}`,\r\n          data: {\r\n            orderNumber: order.id,\r\n            trackingNumber: order.trackingNumber,\r\n            newEstimatedDelivery: calculateNewDeliveryDate()\r\n          }\r\n        });\r\n        \r\n        // Registrar incidencia\r\n        await context.db.create('OrderIncident', {\r\n          orderId: order.id,\r\n          type: 'SHIPPING_DELAY',\r\n          description: 'Retraso en la entrega informado por el transportista',\r\n          timestamp: new Date()\r\n        });\r\n      }\r\n    }\r\n  }\r\n});\n"})}),"\n",(0,o.jsx)(e.h3,{id:"registro-y-uso-de-flujos-de-trabajo",children:"Registro y uso de flujos de trabajo"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// nexusdata.config.js\r\nmodule.exports = {\r\n  // ... otras configuraciones\r\n  workflows: [\r\n    'src/workflows/orderFulfillment',\r\n    'src/workflows/returnProcess',\r\n    'src/workflows/userOnboarding'\r\n  ]\r\n};\r\n\r\n// Uso en resolvers o servicios\r\nconst orderService = {\r\n  async processOrder(orderId, context) {\r\n    // Iniciar flujo de trabajo\r\n    const workflow = context.workflows.orderFulfillment;\r\n    \r\n    // Obtener estado actual\r\n    const currentState = await workflow.getState(orderId);\r\n    \r\n    // Realizar transici\xf3n\r\n    if (currentState === 'RECEIVED') {\r\n      return workflow.transition(orderId, 'startProcessing');\r\n    }\r\n    \r\n    throw new Error(`No se puede procesar orden en estado ${currentState}`);\r\n  },\r\n  \r\n  async markOrderShipped(orderId, context) {\r\n    const workflow = context.workflows.orderFulfillment;\r\n    const currentState = await workflow.getState(orderId);\r\n    \r\n    if (currentState === 'READY_FOR_SHIPPING') {\r\n      return workflow.transition(orderId, 'markShipped');\r\n    }\r\n    \r\n    throw new Error(`No se puede enviar orden en estado ${currentState}`);\r\n  }\r\n};\n"})}),"\n",(0,o.jsx)(e.h2,{id:"pr\xf3ximos-pasos",children:"Pr\xf3ximos pasos"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Aprende a ",(0,o.jsx)(e.a,{href:"/docs/business-logic/validations",children:"implementar validaciones complejas"})]}),"\n",(0,o.jsxs)(e.li,{children:["Explora los ",(0,o.jsx)(e.a,{href:"/docs/testing/unit-testing",children:"patrones para pruebas unitarias"})]}),"\n",(0,o.jsxs)(e.li,{children:["Implementa ",(0,o.jsx)(e.a,{href:"/docs/security/policies",children:"pol\xedticas de seguridad avanzadas"})]}),"\n",(0,o.jsxs)(e.li,{children:["Configura ",(0,o.jsx)(e.a,{href:"/docs/integrations",children:"integraciones con sistemas externos"})]}),"\n"]})]})}function u(r={}){const{wrapper:e}={...(0,a.R)(),...r.components};return e?(0,o.jsx)(e,{...r,children:(0,o.jsx)(l,{...r})}):l(r)}},8453:(r,e,n)=>{n.d(e,{R:()=>i,x:()=>d});var t=n(6540);const o={},a=t.createContext(o);function i(r){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof r?r(e):{...e,...r}}),[e,r])}function d(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(o):r.components||o:i(r.components),t.createElement(a.Provider,{value:e},r.children)}}}]);