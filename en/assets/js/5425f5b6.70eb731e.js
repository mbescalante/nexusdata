"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[92],{3749:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"business-logic/tareas","title":"Tareas en Segundo Plano","description":"Implementaci\xf3n de tareas en segundo plano y trabajos programados en NexusData","source":"@site/docs/business-logic/tareas.md","sourceDirName":"business-logic","slug":"/business-logic/tareas","permalink":"/en/docs/business-logic/tareas","draft":false,"unlisted":false,"editUrl":"https://github.com/nexusdata/nexusdata-docs/edit/main/docs/business-logic/tareas.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Tareas en Segundo Plano","description":"Implementaci\xf3n de tareas en segundo plano y trabajos programados en NexusData"},"sidebar":"tutorialSidebar","previous":{"title":"Sistema de Eventos","permalink":"/en/docs/business-logic/eventos"},"next":{"title":"Flujos de Trabajo","permalink":"/en/docs/business-logic/flujos"}}');var t=n(4848),s=n(8453);const i={sidebar_position:5,title:"Tareas en Segundo Plano",description:"Implementaci\xf3n de tareas en segundo plano y trabajos programados en NexusData"},o="Tareas en Segundo Plano",c={},d=[{value:"Tipos de tareas",id:"tipos-de-tareas",level:2},{value:"Configuraci\xf3n del sistema de tareas",id:"configuraci\xf3n-del-sistema-de-tareas",level:2},{value:"Definici\xf3n de tareas",id:"definici\xf3n-de-tareas",level:2},{value:"Creaci\xf3n de un procesador de tareas",id:"creaci\xf3n-de-un-procesador-de-tareas",level:3},{value:"Registro de tareas",id:"registro-de-tareas",level:3},{value:"Programaci\xf3n de tareas",id:"programaci\xf3n-de-tareas",level:2},{value:"Tareas inmediatas",id:"tareas-inmediatas",level:3},{value:"Tareas programadas",id:"tareas-programadas",level:3},{value:"Tareas recurrentes",id:"tareas-recurrentes",level:3},{value:"Registro de programadores",id:"registro-de-programadores",level:3},{value:"Monitoreo y gesti\xf3n de tareas",id:"monitoreo-y-gesti\xf3n-de-tareas",level:2},{value:"Servicio de administraci\xf3n de tareas",id:"servicio-de-administraci\xf3n-de-tareas",level:3},{value:"Ejemplos de tareas comunes",id:"ejemplos-de-tareas-comunes",level:2},{value:"Procesamiento de importaciones",id:"procesamiento-de-importaciones",level:3},{value:"Env\xedo de correos masivos",id:"env\xedo-de-correos-masivos",level:3},{value:"Mejores pr\xe1cticas",id:"mejores-pr\xe1cticas",level:2}];function l(r){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"tareas-en-segundo-plano",children:"Tareas en Segundo Plano"})}),"\n",(0,t.jsx)(e.p,{children:"Las tareas en segundo plano te permiten ejecutar procesos que requieren mucho tiempo o recursos sin bloquear el hilo principal de tu aplicaci\xf3n, mejorando la experiencia del usuario y el rendimiento general."}),"\n",(0,t.jsx)(e.h2,{id:"tipos-de-tareas",children:"Tipos de tareas"}),"\n",(0,t.jsx)(e.p,{children:"NexusData soporta varios tipos de tareas en segundo plano:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Tareas inmediatas"}),": Se ejecutan tan pronto como sea posible"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Tareas programadas"}),": Se ejecutan en momentos espec\xedficos"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Tareas recurrentes"}),": Se ejecutan peri\xf3dicamente seg\xfan un horario definido"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Tareas condicionales"}),": Se ejecutan cuando se cumplen ciertas condiciones"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"configuraci\xf3n-del-sistema-de-tareas",children:"Configuraci\xf3n del sistema de tareas"}),"\n",(0,t.jsx)(e.p,{children:"Para utilizar el sistema de tareas, debes configurarlo en tu archivo de configuraci\xf3n:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// nexusdata.config.js\r\nmodule.exports = {\r\n  // ... otras configuraciones\r\n  tasks: {\r\n    enabled: true,\r\n    driver: 'redis', // 'redis', 'database', 'memory'\r\n    connection: {\r\n      host: process.env.REDIS_HOST || 'localhost',\r\n      port: process.env.REDIS_PORT || 6379,\r\n      password: process.env.REDIS_PASSWORD\r\n    },\r\n    concurrency: 5, // N\xfamero m\xe1ximo de tareas concurrentes\r\n    defaultQueue: 'default',\r\n    queues: [\r\n      {\r\n        name: 'default',\r\n        concurrency: 3\r\n      },\r\n      {\r\n        name: 'emails',\r\n        concurrency: 5\r\n      },\r\n      {\r\n        name: 'reports',\r\n        concurrency: 1\r\n      },\r\n      {\r\n        name: 'imports',\r\n        concurrency: 2\r\n      }\r\n    ],\r\n    retries: 3, // N\xfamero de reintentos por defecto\r\n    retryDelay: 60000, // Tiempo de espera entre reintentos (ms)\r\n    timeout: 300000, // Tiempo m\xe1ximo de ejecuci\xf3n (ms)\r\n    removeOnComplete: true, // Eliminar tareas completadas\r\n    removeOnFail: false // Mantener tareas fallidas para an\xe1lisis\r\n  }\r\n};\n"})}),"\n",(0,t.jsx)(e.h2,{id:"definici\xf3n-de-tareas",children:"Definici\xf3n de tareas"}),"\n",(0,t.jsx)(e.h3,{id:"creaci\xf3n-de-un-procesador-de-tareas",children:"Creaci\xf3n de un procesador de tareas"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// src/tasks/GenerateReportTask.js\r\nimport { Task } from '@nexusdata/core';\r\n\r\nclass GenerateReportTask extends Task {\r\n  // Nombre de la tarea\r\n  static name = 'generate-report';\r\n  \r\n  // Cola a la que pertenece\r\n  static queue = 'reports';\r\n  \r\n  // N\xfamero de reintentos\r\n  static retries = 2;\r\n  \r\n  // Tiempo de espera entre reintentos (ms)\r\n  static retryDelay = 120000;\r\n  \r\n  // Tiempo m\xe1ximo de ejecuci\xf3n (ms)\r\n  static timeout = 600000;\r\n  \r\n  // M\xe9todo principal que ejecuta la tarea\r\n  async handle(data, context) {\r\n    const { reportId, userId, parameters } = data;\r\n    \r\n    try {\r\n      // Actualizar estado del reporte\r\n      await context.db.update('Report', {\r\n        id: reportId,\r\n        status: 'processing',\r\n        startedAt: new Date()\r\n      });\r\n      \r\n      // Obtener datos para el reporte\r\n      const reportData = await this.fetchReportData(parameters, context);\r\n      \r\n      // Generar archivo del reporte\r\n      const fileUrl = await this.generateReportFile(reportData, parameters, context);\r\n      \r\n      // Actualizar reporte con resultados\r\n      await context.db.update('Report', {\r\n        id: reportId,\r\n        status: 'completed',\r\n        completedAt: new Date(),\r\n        fileUrl,\r\n        resultData: reportData.summary\r\n      });\r\n      \r\n      // Notificar al usuario\r\n      await context.db.create('Notification', {\r\n        userId,\r\n        type: 'report_completed',\r\n        title: 'Reporte completado',\r\n        message: 'Tu reporte ha sido generado y est\xe1 listo para descargar.',\r\n        data: { reportId, fileUrl },\r\n        read: false,\r\n        createdAt: new Date()\r\n      });\r\n      \r\n      // Enviar correo electr\xf3nico\r\n      await context.services.EmailService.sendReportCompletionEmail(userId, reportId, fileUrl);\r\n      \r\n      return { success: true, reportId, fileUrl };\r\n    } catch (error) {\r\n      // Registrar error\r\n      await context.db.create('TaskError', {\r\n        taskName: 'generate-report',\r\n        relatedId: reportId,\r\n        error: error.message,\r\n        stack: error.stack,\r\n        data: JSON.stringify(data),\r\n        createdAt: new Date()\r\n      });\r\n      \r\n      // Actualizar estado del reporte\r\n      await context.db.update('Report', {\r\n        id: reportId,\r\n        status: 'failed',\r\n        error: error.message\r\n      });\r\n      \r\n      // Notificar al usuario sobre el error\r\n      await context.db.create('Notification', {\r\n        userId,\r\n        type: 'report_failed',\r\n        title: 'Error en generaci\xf3n de reporte',\r\n        message: `Ocurri\xf3 un error al generar tu reporte: ${error.message}`,\r\n        data: { reportId },\r\n        read: false,\r\n        createdAt: new Date()\r\n      });\r\n      \r\n      // Re-lanzar el error para que el sistema de tareas lo maneje\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  async fetchReportData(parameters, context) {\r\n    // Implementaci\xf3n para obtener datos del reporte\r\n    // ...\r\n    \r\n    return {\r\n      // Datos del reporte\r\n      items: [],\r\n      summary: {}\r\n    };\r\n  }\r\n  \r\n  async generateReportFile(data, parameters, context) {\r\n    // Implementaci\xf3n para generar archivo (PDF, Excel, etc.)\r\n    // ...\r\n    \r\n    return 'https://storage.example.com/reports/report-123.pdf';\r\n  }\r\n  \r\n  // M\xe9todo que se ejecuta si la tarea falla despu\xe9s de todos los reintentos\r\n  async failed(data, error, context) {\r\n    const { reportId, userId } = data;\r\n    \r\n    // Enviar notificaci\xf3n al equipo de soporte\r\n    await context.services.NotificationService.notifyTeam('support', {\r\n      title: 'Fallo cr\xedtico en generaci\xf3n de reporte',\r\n      message: `Reporte #${reportId} fall\xf3 despu\xe9s de ${this.constructor.retries} intentos: ${error.message}`,\r\n      data: { reportId, error: error.message, userId }\r\n    });\r\n  }\r\n  \r\n  // M\xe9todo que se ejecuta antes de cada intento\r\n  async beforeAttempt(data, attemptNumber, context) {\r\n    const { reportId } = data;\r\n    \r\n    // Registrar intento\r\n    await context.db.create('TaskAttempt', {\r\n      taskName: 'generate-report',\r\n      relatedId: reportId,\r\n      attemptNumber,\r\n      startedAt: new Date()\r\n    });\r\n    \r\n    // Actualizar estado del reporte si es un reintento\r\n    if (attemptNumber > 1) {\r\n      await context.db.update('Report', {\r\n        id: reportId,\r\n        status: 'retrying',\r\n        retryCount: attemptNumber - 1\r\n      });\r\n    }\r\n  }\r\n  \r\n  // M\xe9todo que se ejecuta despu\xe9s de cada intento\r\n  async afterAttempt(data, attemptNumber, success, error, context) {\r\n    const { reportId } = data;\r\n    \r\n    // Actualizar registro de intento\r\n    await context.db.update('TaskAttempt', {\r\n      where: {\r\n        taskName: 'generate-report',\r\n        relatedId: reportId,\r\n        attemptNumber\r\n      },\r\n      data: {\r\n        completedAt: new Date(),\r\n        success,\r\n        error: error ? error.message : null\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default GenerateReportTask;\n"})}),"\n",(0,t.jsx)(e.h3,{id:"registro-de-tareas",children:"Registro de tareas"}),"\n",(0,t.jsx)(e.p,{children:"Para que tus tareas est\xe9n disponibles en la aplicaci\xf3n, debes registrarlas en el archivo de configuraci\xf3n:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// nexusdata.config.js\r\nmodule.exports = {\r\n  // ... otras configuraciones\r\n  tasks: {\r\n    // ... configuraci\xf3n de tareas\r\n    handlers: [\r\n      'src/tasks/GenerateReportTask',\r\n      'src/tasks/ProcessImportTask',\r\n      'src/tasks/SendBulkEmailTask',\r\n      'src/tasks/CleanupFilesTask'\r\n    ]\r\n  }\r\n};\n"})}),"\n",(0,t.jsx)(e.h2,{id:"programaci\xf3n-de-tareas",children:"Programaci\xf3n de tareas"}),"\n",(0,t.jsx)(e.h3,{id:"tareas-inmediatas",children:"Tareas inmediatas"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// src/services/ReportService.js\r\nimport { Service } from '@nexusdata/core';\r\n\r\nclass ReportService extends Service {\r\n  async createReport(data, context) {\r\n    // Crear registro de reporte\r\n    const report = await this.db.create('Report', {\r\n      name: data.name,\r\n      type: data.type,\r\n      parameters: data.parameters,\r\n      userId: context.user.id,\r\n      status: 'pending',\r\n      createdAt: new Date()\r\n    });\r\n    \r\n    // Programar tarea inmediata\r\n    await this.tasks.dispatch('generate-report', {\r\n      reportId: report.id,\r\n      userId: context.user.id,\r\n      parameters: data.parameters\r\n    });\r\n    \r\n    return report;\r\n  }\r\n}\r\n\r\nexport default ReportService;\n"})}),"\n",(0,t.jsx)(e.h3,{id:"tareas-programadas",children:"Tareas programadas"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// src/services/EmailCampaignService.js\r\nimport { Service } from '@nexusdata/core';\r\n\r\nclass EmailCampaignService extends Service {\r\n  async scheduleCampaign(data, context) {\r\n    // Validar fecha de env\xedo\r\n    const sendAt = new Date(data.sendAt);\r\n    \r\n    if (sendAt <= new Date()) {\r\n      throw new Error('La fecha de env\xedo debe ser en el futuro');\r\n    }\r\n    \r\n    // Crear campa\xf1a\r\n    const campaign = await this.db.create('EmailCampaign', {\r\n      name: data.name,\r\n      subject: data.subject,\r\n      content: data.content,\r\n      recipientListId: data.recipientListId,\r\n      status: 'scheduled',\r\n      scheduledFor: sendAt,\r\n      createdBy: context.user.id,\r\n      createdAt: new Date()\r\n    });\r\n    \r\n    // Programar tarea para una fecha espec\xedfica\r\n    await this.tasks.schedule('send-bulk-email', {\r\n      campaignId: campaign.id,\r\n      recipientListId: data.recipientListId\r\n    }, {\r\n      runAt: sendAt\r\n    });\r\n    \r\n    return campaign;\r\n  }\r\n}\r\n\r\nexport default EmailCampaignService;\n"})}),"\n",(0,t.jsx)(e.h3,{id:"tareas-recurrentes",children:"Tareas recurrentes"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// src/tasks/schedulers/RecurringTasksScheduler.js\r\nimport { TaskScheduler } from '@nexusdata/core';\r\n\r\nclass RecurringTasksScheduler extends TaskScheduler {\r\n  initialize() {\r\n    // Tarea diaria a medianoche\r\n    this.schedule('cleanup-files', {}, {\r\n      cron: '0 0 * * *', // Formato cron: minuto hora d\xeda-mes mes d\xeda-semana\r\n      timezone: 'Europe/Madrid'\r\n    });\r\n    \r\n    // Tarea semanal los lunes a las 8:00 AM\r\n    this.schedule('generate-weekly-report', {\r\n      reportType: 'weekly-summary'\r\n    }, {\r\n      cron: '0 8 * * 1',\r\n      timezone: 'Europe/Madrid'\r\n    });\r\n    \r\n    // Tarea mensual el primer d\xeda del mes\r\n    this.schedule('generate-monthly-report', {\r\n      reportType: 'monthly-summary'\r\n    }, {\r\n      cron: '0 9 1 * *',\r\n      timezone: 'Europe/Madrid'\r\n    });\r\n    \r\n    // Tarea cada 15 minutos\r\n    this.schedule('check-pending-orders', {}, {\r\n      cron: '*/15 * * * *'\r\n    });\r\n    \r\n    // Tarea cada hora durante horario laboral\r\n    this.schedule('sync-inventory', {}, {\r\n      cron: '0 9-18 * * 1-5' // Cada hora de 9 AM a 6 PM, lunes a viernes\r\n    });\r\n  }\r\n}\r\n\r\nexport default RecurringTasksScheduler;\n"})}),"\n",(0,t.jsx)(e.h3,{id:"registro-de-programadores",children:"Registro de programadores"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// nexusdata.config.js\r\nmodule.exports = {\r\n  // ... otras configuraciones\r\n  tasks: {\r\n    // ... configuraci\xf3n de tareas\r\n    schedulers: [\r\n      'src/tasks/schedulers/RecurringTasksScheduler',\r\n      'src/tasks/schedulers/MaintenanceTasksScheduler'\r\n    ]\r\n  }\r\n};\n"})}),"\n",(0,t.jsx)(e.h2,{id:"monitoreo-y-gesti\xf3n-de-tareas",children:"Monitoreo y gesti\xf3n de tareas"}),"\n",(0,t.jsx)(e.h3,{id:"servicio-de-administraci\xf3n-de-tareas",children:"Servicio de administraci\xf3n de tareas"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// src/services/TaskManagerService.js\r\nimport { Service } from '@nexusdata/core';\r\n\r\nclass TaskManagerService extends Service {\r\n  async getTaskStatus(taskId) {\r\n    return this.tasks.getStatus(taskId);\r\n  }\r\n  \r\n  async listPendingTasks(queue = null, limit = 100) {\r\n    return this.tasks.listPending(queue, limit);\r\n  }\r\n  \r\n  async listActiveTasks(queue = null) {\r\n    return this.tasks.listActive(queue);\r\n  }\r\n  \r\n  async listFailedTasks(queue = null, limit = 100) {\r\n    return this.tasks.listFailed(queue, limit);\r\n  }\r\n  \r\n  async retryTask(taskId) {\r\n    return this.tasks.retry(taskId);\r\n  }\r\n  \r\n  async retryAllFailedTasks(queue = null) {\r\n    return this.tasks.retryAllFailed(queue);\r\n  }\r\n  \r\n  async cancelTask(taskId) {\r\n    return this.tasks.cancel(taskId);\r\n  }\r\n  \r\n  async pauseQueue(queue) {\r\n    return this.tasks.pauseQueue(queue);\r\n  }\r\n  \r\n  async resumeQueue(queue) {\r\n    return this.tasks.resumeQueue(queue);\r\n  }\r\n  \r\n  async getQueueStats(queue = null) {\r\n    return this.tasks.getQueueStats(queue);\r\n  }\r\n  \r\n  async clearQueue(queue) {\r\n    return this.tasks.clearQueue(queue);\r\n  }\r\n}\r\n\r\nexport default TaskManagerService;\n"})}),"\n",(0,t.jsx)(e.h2,{id:"ejemplos-de-tareas-comunes",children:"Ejemplos de tareas comunes"}),"\n",(0,t.jsx)(e.h3,{id:"procesamiento-de-importaciones",children:"Procesamiento de importaciones"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// src/tasks/ProcessImportTask.js\r\nimport { Task } from '@nexusdata/core';\r\nimport fs from 'fs';\r\nimport csv from 'csv-parser';\r\n\r\nclass ProcessImportTask extends Task {\r\n  static name = 'process-import';\r\n  static queue = 'imports';\r\n  static retries = 2;\r\n  static timeout = 1800000; // 30 minutos\r\n  \r\n  async handle(data, context) {\r\n    const { importId, filePath, options } = data;\r\n    \r\n    try {\r\n      // Actualizar estado de importaci\xf3n\r\n      await context.db.update('Import', {\r\n        id: importId,\r\n        status: 'processing',\r\n        startedAt: new Date()\r\n      });\r\n      \r\n      // Procesar archivo\r\n      const results = await this.processFile(filePath, options, context);\r\n      \r\n      // Actualizar estado de importaci\xf3n\r\n      await context.db.update('Import', {\r\n        id: importId,\r\n        status: 'completed',\r\n        completedAt: new Date(),\r\n        processedRows: results.processed,\r\n        successRows: results.success,\r\n        errorRows: results.errors.length,\r\n        summary: results.summary\r\n      });\r\n      \r\n      // Guardar errores detallados\r\n      if (results.errors.length > 0) {\r\n        for (const error of results.errors) {\r\n          await context.db.create('ImportError', {\r\n            importId,\r\n            row: error.row,\r\n            column: error.column,\r\n            value: error.value,\r\n            error: error.message,\r\n            createdAt: new Date()\r\n          });\r\n        }\r\n      }\r\n      \r\n      // Notificar al usuario\r\n      const importRecord = await context.db.findOne('Import', { id: importId });\r\n      \r\n      await context.db.create('Notification', {\r\n        userId: importRecord.createdBy,\r\n        type: 'import_completed',\r\n        title: 'Importaci\xf3n completada',\r\n        message: `Tu importaci\xf3n \"${importRecord.name}\" ha sido procesada. ${results.success} registros importados correctamente.`,\r\n        data: { importId, results: results.summary },\r\n        read: false,\r\n        createdAt: new Date()\r\n      });\r\n      \r\n      return results;\r\n    } catch (error) {\r\n      // Actualizar estado de importaci\xf3n\r\n      await context.db.update('Import', {\r\n        id: importId,\r\n        status: 'failed',\r\n        error: error.message\r\n      });\r\n      \r\n      // Notificar al usuario\r\n      const importRecord = await context.db.findOne('Import', { id: importId });\r\n      \r\n      await context.db.create('Notification', {\r\n        userId: importRecord.createdBy,\r\n        type: 'import_failed',\r\n        title: 'Error en importaci\xf3n',\r\n        message: `Ocurri\xf3 un error al procesar tu importaci\xf3n \"${importRecord.name}\": ${error.message}`,\r\n        data: { importId },\r\n        read: false,\r\n        createdAt: new Date()\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  async processFile(filePath, options, context) {\r\n    const results = {\r\n      processed: 0,\r\n      success: 0,\r\n      errors: [],\r\n      summary: {}\r\n    };\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      const rows = [];\r\n      \r\n      fs.createReadStream(filePath)\r\n        .pipe(csv())\r\n        .on('data', (row) => {\r\n          rows.push(row);\r\n        })\r\n        .on('end', async () => {\r\n          try {\r\n            // Procesar filas en lotes para mejor rendimiento\r\n            const batchSize = 100;\r\n            \r\n            for (let i = 0; i < rows.length; i += batchSize) {\r\n              const batch = rows.slice(i, i + batchSize);\r\n              \r\n              // Procesar lote\r\n              await context.db.transaction(async (tx) => {\r\n                for (const [index, row] of batch.entries()) {\r\n                  try {\r\n                    results.processed++;\r\n                    \r\n                    // Transformar datos seg\xfan el tipo de importaci\xf3n\r\n                    const transformedData = this.transformRow(row, options);\r\n                    \r\n                    // Validar datos\r\n                    this.validateRow(transformedData, options);\r\n                    \r\n                    // Insertar o actualizar en la base de datos\r\n                    if (options.updateExisting && transformedData.id) {\r\n                      await tx.update(options.model, transformedData);\r\n                    } else {\r\n                      await tx.create(options.model, transformedData);\r\n                    }\r\n                    \r\n                    results.success++;\r\n                  } catch (error) {\r\n                    results.errors.push({\r\n                      row: i + index + 1, // +1 para contar el encabezado\r\n                      data: row,\r\n                      message: error.message\r\n                    });\r\n                  }\r\n                }\r\n              });\r\n              \r\n              // Actualizar progreso\r\n              await context.db.update('Import', {\r\n                id: options.importId,\r\n                progress: Math.floor((i + batch.length) / rows.length * 100)\r\n              });\r\n            }\r\n            \r\n            // Generar resumen\r\n            results.summary = {\r\n              total: rows.length,\r\n              processed: results.processed,\r\n              success: results.success,\r\n              failed: results.errors.length\r\n            };\r\n            \r\n            resolve(results);\r\n          } catch (error) {\r\n            reject(error);\r\n          }\r\n        })\r\n        .on('error', (error) => {\r\n          reject(error);\r\n        });\r\n    });\r\n  }\r\n  \r\n  transformRow(row, options) {\r\n    // Implementaci\xf3n espec\xedfica seg\xfan el tipo de importaci\xf3n\r\n    // ...\r\n    \r\n    return transformedData;\r\n  }\r\n  \r\n  validateRow(data, options) {\r\n    // Implementaci\xf3n espec\xedfica seg\xfan el tipo de importaci\xf3n\r\n    // ...\r\n    \r\n    if (!valid) {\r\n      throw new Error('Datos inv\xe1lidos');\r\n    }\r\n  }\r\n}\r\n\r\nexport default ProcessImportTask;\n"})}),"\n",(0,t.jsx)(e.h3,{id:"env\xedo-de-correos-masivos",children:"Env\xedo de correos masivos"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// src/tasks/SendBulkEmailTask.js\r\nimport { Task } from '@nexusdata/core';\r\n\r\nclass SendBulkEmailTask extends Task {\r\n  static name = 'send-bulk-email';\r\n  static queue = 'emails';\r\n  static retries = 3;\r\n  static timeout = 3600000; // 1 hora\r\n  \r\n  async handle(data, context) {\r\n    const { campaignId } = data;\r\n    \r\n    try {\r\n      // Obtener campa\xf1a\r\n      const campaign = await context.db.findOne('EmailCampaign', { id: campaignId });\r\n      \r\n      if (!campaign) {\r\n        throw new Error(`Campa\xf1a no encontrada: ${campaignId}`);\r\n      }\r\n      \r\n      // Actualizar estado\r\n      await context.db.update('EmailCampaign', {\r\n        id: campaignId,\r\n        status: 'sending',\r\n        startedAt: new Date()\r\n      });\r\n      \r\n      // Obtener lista de destinatarios\r\n      const recipients = await context.db.findMany('EmailRecipient', {\r\n        where: { listId: campaign.recipientListId }\r\n      });\r\n      \r\n      // Inicializar contadores\r\n      let sent = 0;\r\n      let failed = 0;\r\n      const errors = [];\r\n      \r\n      // Enviar correos en lotes\r\n      const batchSize = 50;\r\n      \r\n      for (let i = 0; i < recipients.length; i += batchSize) {\r\n        const batch = recipients.slice(i, i + batchSize);\r\n        \r\n        // Procesar lote\r\n        const results = await Promise.allSettled(\r\n          batch.map(recipient => this.sendEmail(recipient, campaign, context))\r\n        );\r\n        \r\n        // Actualizar contadores\r\n        for (const result of results) {\r\n          if (result.status === 'fulfilled') {\r\n            sent++;\r\n          } else {\r\n            failed++;\r\n            errors.push({\r\n              email: result.reason.email,\r\n              error: result.reason.message\r\n            });\r\n          }\r\n        }\r\n        \r\n        // Actualizar progreso\r\n        await context.db.update('EmailCampaign', {\r\n          id: campaignId,\r\n          progress: Math.floor((i + batch.length) / recipients.length * 100),\r\n          sentCount: sent,\r\n          failedCount: failed\r\n        });\r\n      }\r\n      \r\n      // Actualizar estado final\r\n      await context.db.update('EmailCampaign', {\r\n        id: campaignId,\r\n        status: 'completed',\r\n        completedAt: new Date(),\r\n        sentCount: sent,\r\n        failedCount: failed,\r\n        summary: {\r\n          total: recipients.length,\r\n          sent,\r\n          failed,\r\n          errors: errors.slice(0, 100) // Limitar n\xfamero de errores guardados\r\n        }\r\n      });\r\n      \r\n      // Notificar al creador\r\n      await context.db.create('Notification', {\r\n        userId: campaign.createdBy,\r\n        type: 'campaign_completed',\r\n        title: 'Campa\xf1a de correo completada',\r\n        message: `Tu campa\xf1a \"${campaign.name}\" ha sido enviada. ${sent} correos enviados correctamente.`,\r\n        data: { campaignId, sent, failed },\r\n        read: false,\r\n        createdAt: new Date()\r\n      });\r\n      \r\n      return {\r\n        campaignId,\r\n        total: recipients.length,\r\n        sent,\r\n        failed\r\n      };\r\n    } catch (error) {\r\n      // Actualizar estado en caso de error\r\n      await context.db.update('EmailCampaign', {\r\n        id: campaignId,\r\n        status: 'failed',\r\n        error: error.message\r\n      });\r\n      \r\n      // Notificar al creador\r\n      const campaign = await context.db.findOne('EmailCampaign', { id: campaignId });\r\n      \r\n      await context.db.create('Notification', {\r\n        userId: campaign.createdBy,\r\n        type: 'campaign_failed',\r\n        title: 'Error en campa\xf1a de correo',\r\n        message: `Ocurri\xf3 un error al enviar tu campa\xf1a \"${campaign.name}\": ${error.message}`,\r\n        data: { campaignId },\r\n        read: false,\r\n        createdAt: new Date()\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  async sendEmail(recipient, campaign, context) {\r\n    try {\r\n      // Personalizar contenido\r\n      const personalizedContent = this.personalizeContent(campaign.content, recipient);\r\n      \r\n      // Enviar correo\r\n      await context.services.EmailService.send({\r\n        to: recipient.email,\r\n        subject: campaign.subject,\r\n        html: personalizedContent,\r\n        from: campaign.fromEmail || 'noreply@example.com',\r\n        campaignId: campaign.id\r\n      });\r\n      \r\n      // Registrar env\xedo exitoso\r\n      await context.db.create('EmailLog', {\r\n        campaignId: campaign.id,\r\n        recipientId: recipient.id,\r\n        email: recipient.email,\r\n        status: 'sent',\r\n        sentAt: new Date()\r\n      });\r\n      \r\n      return { success: true, email: recipient.email };\r\n    } catch (error) {\r\n      // Registrar error\r\n      await context.db.create('EmailLog', {\r\n        campaignId: campaign.id,\r\n        recipientId: recipient.id,\r\n        email: recipient.email,\r\n        status: 'failed',\r\n        error: error.message,\r\n        sentAt: new Date()\r\n      });\r\n      \r\n      throw { email: recipient.email, message: error.message };\r\n    }\r\n  }\r\n  \r\n  personalizeContent(content, recipient) {\r\n    // Reemplazar variables de plantilla\r\n    let personalized = content;\r\n    \r\n    // Reemplazar variables b\xe1sicas\r\n    personalized = personalized.replace(/{{name}}/g, recipient.name || '');\r\n    personalized = personalized.replace(/{{email}}/g, recipient.email);\r\n    \r\n    // Reemplazar variables personalizadas\r\n    if (recipient.data) {\r\n      for (const [key, value] of Object.entries(recipient.data)) {\r\n        personalized = personalized.replace(new RegExp(`{{${key}}}`, 'g'), value || '');\r\n      }\r\n    }\r\n    \r\n    return personalized;\r\n  }\r\n}\r\n\r\nexport default SendBulkEmailTask;\n"})}),"\n",(0,t.jsx)(e.h2,{id:"mejores-pr\xe1cticas",children:"Mejores pr\xe1cticas"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Idempotencia"}),": Dise\xf1a tus tareas para ser idempotentes (pueden ejecutarse m\xfaltiples veces sin efectos secundarios)."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Transacciones"}),": Usa transacciones para operaciones que modifican m\xfaltiples registros."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Manejo de errores"}),": Implementa un manejo de errores robusto y registra detalles para facilitar la depuraci\xf3n."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Progreso"}),": Actualiza el progreso de tareas largas para proporcionar retroalimentaci\xf3n."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Notificaciones"}),": Notifica a los usuarios cuando las tareas se completan o fallan."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Monitoreo"}),": Implementa m\xe9tricas y registros para monitorear el rendimiento y la salud del sistema de tareas."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"L\xedmites de recursos"}),": Establece l\xedmites de tiempo y memoria para evitar que tareas problem\xe1ticas afecten todo el sistema."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Priorizaci\xf3n"}),": Usa diferentes colas para priorizar tareas cr\xedticas."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Reintentos"}),": Configura pol\xedticas de reintento adecuadas para diferentes tipos de tareas."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Escalabilidad"}),": Dise\xf1a tu sistema de tareas para escalar horizontalmente cuando sea necesario."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{})})]})}function p(r={}){const{wrapper:e}={...(0,s.R)(),...r.components};return e?(0,t.jsx)(e,{...r,children:(0,t.jsx)(l,{...r})}):l(r)}},8453:(r,e,n)=>{n.d(e,{R:()=>i,x:()=>o});var a=n(6540);const t={},s=a.createContext(t);function i(r){const e=a.useContext(s);return a.useMemo((function(){return"function"==typeof r?r(e):{...e,...r}}),[e,r])}function o(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:i(r.components),a.createElement(s.Provider,{value:e},r.children)}}}]);